#!/usr/bin/env ruby

require 'scv'
require 'gli'

include GLI::App

program_desc 'A simple VCS implemented in Ruby on top of the VCSToolkit library'

version SCV::VERSION

desc   'Print more stuff'
switch [:v, :verbose]

desc          'The path to the working directory'
default_value '.'
arg_name      'directory path'
flag          [:dir]

desc 'Initialize an empty repository.'
command :init do |config|
  config.action do |global_options, options, args|
    path = global_options[:dir]

    if File.directory? File.join(path, '.scv')
      raise "There is already an SCV repository #{path == '.' ? 'here' : 'at ' + path}"
    end

    SCV::Repository.create_at path

    puts "Job's finished!"
    puts "You can now use `scv commit` to create your first commit!"
  end
end

desc 'Commits the current state of the working directory.'
arg_name ''
command :commit do |c|
  c.desc          'The commit message'
  c.arg_name      'message'
  c.flag          [:m, :message]

  c.desc          'The commit author name and email.'
  c.arg_name      'author'
  c.flag          :author

  c.desc          'Use this to override the timestamp of the commit.'
  c.arg_name      'date'
  c.default_value DateTime.now
  c.flag          :date

  c.action do |global_options, options, args|
    repository = SCV::Repository.new global_options[:dir]
    repository_path  = "#{global_options[:dir]}/.scv"
    status = repository.status repository[:head].reference_id, ignore: [/^\.|\/\./]

    if status.none? { |_, files| files.any? }
      raise 'No changes since last commit'
    end

    unless options[:author]
      raise 'Please provide an author with --author="..." or set it globally with `scv config -g author ...`'
    end

    if options[:message]
      commit_message = options[:message].strip
    else
      commit_message_file = "#{repository_path}/COMMIT_MESSAGE"

      system "$EDITOR #{commit_message_file}"
      File.open(commit_message_file, 'r') do |file|
        commit_message = file.read.strip
      end
      FileUtils.rm commit_message_file
    end

    if commit_message.empty?
      raise 'The commit message cannot be empty'
    end

    date = options[:date].is_a?(String) ? DateTime.parse(options[:date]) : options[:date]

    repository.commit commit_message,
                      options[:author],
                      date,
                      ignore: [/^\.|\/\./]
  end
end

desc 'Shows the created, modified and deleted files'
arg_name ''
command :status do |c|
  c.action do |global_options, options, args|
    repository = SCV::Repository.new global_options[:dir]
    status     = repository.status repository[:head].reference_id,
                                   ignore: [/^\.|\/\./]

    puts "# On commit #{repository.head}"
    puts

    if status.none? { |_, files| files.any? }
      puts "# No changes"
    end

    if status[:changed].any?
      puts "# Changed:"
      puts status[:changed].map { |file| "+-  #{file}" }
      puts
    end

    if status[:created].any?
      puts "# New:"
      puts status[:created].map { |file| "+   #{file}" }
      puts
    end

    if status[:deleted].any?
      puts "# Deleted:"
      puts status[:deleted].map { |file| "-   #{file}" }
      puts
    end
  end
end

desc 'Displays the commit history'
arg_name ''
command [:history, :log] do |c|
  c.action do |global_options, options, args|
    repository = SCV::Repository.new global_options[:dir]

    repository.history.each do |commit|
      puts "Commit #{commit.object_id}"
      puts "Author #{commit.author}"
      puts "Date   #{commit.date.strftime "%A %Y-%m-%d %H:%M:%S %z"}"

      puts
      puts commit.message.lines.map { |line| "    #{line}" }.join("\n")
      puts
    end
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)